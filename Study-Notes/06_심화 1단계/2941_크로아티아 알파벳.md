# 2025-12-19
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **문제 요약**: 입력된 문자열에서 크로아티아 알파벳(`c=`, `c-`, `dz=`, `d-`, `lj`, `nj`, `s=`, `z=`)의 개수를 세는 문제이다.
- **핵심 조건**: 
    1. 위 목록에 있는 특수 형태는 **한 글자**로 취급한다.
    2. 목록에 없는 일반 알파벳도 **한 글자**로 취급한다.
    3. `dz=`와 `z=`처럼 포함 관계가 있는 경우, 긴 것(`dz=`)이 우선순위를 가진다.

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **변수 설정**: 
    - 변경할 크로아티아 알파벳 8개를 담은 `String` 배열 (`croatiaAlphabet`) 생성.
2. **알고리즘 설계 (치환)**: 
    - 복잡하게 인덱스를 계산하거나 `count` 변수를 따로 두는 대신, **특수 패턴을 길이 1짜리 임의의 문자(예: "!")로 치환**하는 방식을 사용한다.
    - 배열을 순회하며 `str.replace(패턴, "!")`를 수행한다.
    - 이때, `dz=`가 `z=`보다 배열의 앞쪽에 위치하거나 먼저 처리되어야 중복 카운팅 오류를 막을 수 있다.
3. **결과 도출**: 
    - 치환이 완료된 문자열의 길이(`str.length()`)가 곧 정답이 된다.
4. **시간 복잡도**: 
    - 문자열의 길이가 최대 100이므로, `replace` 함수를 여러 번 사용해도 시간 내에 충분히 통과한다.

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Silver/2941. 크로아티아 알파벳/)
---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **틀린 이유**: 
    - 처음에는 `if (str.contains("c=")) count++` 방식으로 접근함.
    - 이 방식은 같은 패턴이 여러 번 나올 때(예: `c=c=`) 한 번만 세는 문제가 있었고, 패턴이 아닌 일반 문자(a, b 등)를 세지 못하는 논리적 오류가 있었음.
- **배운 점**: 
    - **치환(Replace) 아이디어**: 문자열 개수 세기 문제에서 특정 패턴을 단순화(길이 1의 문자로 변경)하면 `length()` 만으로 답을 구할 수 있다는 점을 배움.
    - `dz=`와 `z=` 처럼 포함 관계가 있는 경우, 긴 문자열을 먼저 치환해야 올바르게 처리된다는 점을 주의해야 함.````