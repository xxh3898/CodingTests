# 2025-12-22
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **요약**: $N \times M$ 크기의 두 행렬 $A$와 $B$가 주어졌을 때, 두 행렬을 더하는 프로그램을 작성한다.
- **핵심 조건**: 
	- 같은 위치에 있는 원소끼리 더해야 한다. (행렬 덧셈의 기본 성질)
	- 입력받은 $N$과 $M$ 크기에 맞춰 2차원 배열을 생성해야 한다.

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **변수 설정:** 
	- 행렬의 크기를 나타낼 `n`(행), `m`(열).
	- 두 행렬의 값을 저장할 2차원 배열 `arr1`, `arr2`.
2. **로직 설계:** 
	- `n`, `m`을 입력받고 배열 크기를 할당한다.
	- 이중 `for`문을 사용하여 첫 번째 행렬(`arr1`)의 값을 입력받는다.
	- 이중 `for`문을 사용하여 두 번째 행렬(`arr2`)의 값을 입력받는다.
	- 다시 이중 `for`문을 돌며 `arr1[i][j] += arr2[i][j]` 연산을 통해 값을 합친다.
	- 합쳐진 `arr1`을 출력한다.
3. **시간 복잡도:** 모든 원소를 한 번씩 순회하며 입력받고 더하므로 $O(N \times M)$이다.

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Bronze/2738. 행렬 덧셈/)

---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **배운 점:** - 2차원 배열의 선언과 인덱스 접근 방식을 복습했다.
	- 이중 반복문을 통해 행렬 데이터를 처리하는 로직을 구현했다.
	
- **다른 사람 풀이 참고 (최적화):** 
	- 현재 코드는 `arr2`를 모두 입력받은 뒤 다시 덧셈 루프를 돌리고 있다.
	- **메모리/시간 절약 팁**: `arr2` 배열을 따로 만들지 않고, 두 번째 행렬 입력을 받을 때 `arr1`에 바로 더해버리면 메모리 공간을 절반으로 줄이고 반복문 횟수도 줄일 수 있다.

```java
    // 예시: 두 번째 행렬 입력과 동시에 덧셈
    for (int i = 0; i < n; i++) {
        st = new StringTokenizer(br.readLine());
        for (int j = 0; j < m; j++) {
            // arr2를 만들지 않고 바로 더하기
            arr1[i][j] += Integer.parseInt(st.nextToken());
        }
    }
```