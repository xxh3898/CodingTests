# 2026-01-02  
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **문제 요약**: 1/1부터 시작해 분수를 대각선 순서로 나열했을 때, N번째에 오는 분수를 구하는 문제이다.
- **핵심 조건**:  
	- 분수는 대각선 단위로 묶인다.
	- 대각선 번호가 홀수/짝수인지에 따라 분자와 분모의 증가 방향이 달라진다.
	- N은 1 이상의 자연수이다.

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **변수 설정:**  
	- `line`: 현재 대각선 번호  
	 - `sum`: 현재 대각선까지의 분수 총 개수  
	- `pos`: 해당 대각선 안에서 N의 위치  
	- `a, b`: 최종 분자와 분모

2. **조건문 설계:**  
	- while문으로 `sum < n`인 동안 대각선 번호(`line`)를 증가시키며 누적 개수 계산  
	- `pos = n - (sum - line)`으로 대각선 내부 위치 계산  
	- `line`이 짝수면 분자 증가 / 홀수면 분모 증가 규칙 적용

3. **시간 복잡도:**  
	- O(√N) (대각선 누적 합이 N을 넘을 때까지 증가)

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Silver/1193. 분수찾기/)

---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **틀린 이유:**  
	- 처음에 while 조건을 `line >= n`으로 잘못 설정함  
	- 분자 변수(`a`)를 대각선 누적 계산에 사용하려다 로직이 꼬였음

- **배운 점:**  
	- 수열 문제는 직접 나열해 보고 규칙을 찾는 게 가장 중요함  
	- 누적합을 사용하면 위치 계산이 깔끔해진다  
	- 변수의 역할을 명확히 분리해야 디버깅이 쉬워진다

- **다른 사람 풀이 참고:**  
	- 대각선 번호를 구한 뒤, 홀짝에 따라 분자/분모를 계산하는 방식이 대부분 동일함