# 2026-01-01
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **요약**: 육각형으로 이루어진 벌집 모양에서 중앙(1)에서 출발하여 특정 방 번호($N$)까지 이동할 때, 지나가는 방의 최소 개수(시작과 끝 포함)를 구하는 문제.
- **핵심 조건**: 
	- 중앙의 방 1부터 시작한다 (거리 1).
	- 벌집은 육각형 모양으로 층(Layer)이 겹겹이 둘러싸며 커진다.
	- 한 층을 지날 때마다 방의 개수는 6의 배수만큼 늘어난다.
	- 즉, $N$이 몇 번째 껍질(Layer)에 위치하는지를 구하면 된다.

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **규칙 찾기 (범위 설정)**
	- 1단계 (거리 1): 방 1개 (번호 1) $\rightarrow$ 범위 끝: 1
	- 2단계 (거리 2): 방 6개 추가 (2 ~ 7) $\rightarrow$ 범위 끝: $1 + 6 = 7$
	- 3단계 (거리 3): 방 12개 추가 (8 ~ 19) $\rightarrow$ 범위 끝: $7 + 12 = 19$
	- 4단계 (거리 4): 방 18개 추가 (20 ~ 37) $\rightarrow$ 범위 끝: $19 + 18 = 37$
   
2. **알고리즘 설계**
	 - 입력값 `n`이 현재 범위의 최댓값(`box`)보다 크다면, 다음 껍질로 넘어간다.
	 - 껍질이 늘어날 때마다 `box`에 `6 * count`를 더해준다.
	- `count`를 1씩 증가시키며 반복한다.
	- `n`이 `box` 안에 들어오면 반복을 멈추고 `count`를 출력한다.

3. **시간 복잡도:**
	- 범위가 등차수열의 합($\approx 3k^2$) 형태로 커지므로, 반복 횟수는 약 $\sqrt{N}$에 비례한다. 
	- $N$이 최대 10억이어도 충분히 시간 내에 통과 가능하다. $O(\sqrt{N})$

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Bronze/2292. 벌집)

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
		
        int n = sc.nextInt();
        int box = 1;      // 해당 껍질(Layer)의 최댓값 (초기값 1)
        int count = 1;    // 지나가는 방의 개수 (초기값 1)
		
        // n이 현재 범위(box)보다 크다면 껍질을 계속 넓혀감
        while (n > box) {
            box += 6 * count; // 6, 12, 18... 씩 증가
            count += 1;       // 거리 증가
        }
		
        System.out.println(count);
    }
}
```

---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **배운 점:** 
	- 계차수열(차이가 등차수열인 수열) 형태의 문제는 누적 합을 통해 범위를 갱신해 나가는 방식이 효율적임을 확인함.
- **다른 사람 풀이 참고 (수학적 공식 $O(1)$):** 
	- 반복문을 돌지 않고 **근의 공식**을 이용해 바로 답을 구하는 방법도 존재함.
	- $K$번째 껍질의 마지막 방 번호는 $3K^2 - 3K + 1$ 공식을 따름. 
	- $3K^2 - 3K + (1-N) \ge 0$ 부등식을 만족하는 최소 정수 $K$를 찾으면 됨. 
	- **결론:** $N$이 10억이어도 반복문 방식($O(\sqrt{N})$)이 충분히 빠르므로, 가독성 측면에서 현재 내 풀이도 훌륭함.