# 2025-12-31
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **요약**: 정사각형의 각 변의 중앙과 중심에 점을 추가하는 과정을 $N$번 반복했을 때, 총 점의 개수를 구하는 문제.
- **핵심 조건**: 
	- 초기 상태(0단계)는 한 변의 점이 2개($2 \times 2 = 4$개)이다.
	- 단계를 거칠 때마다 한 변에 있는 점의 개수가 늘어난다.
	- 전체 점의 개수는 `(한 변의 점의 개수)의 제곱`이다.
	- 한 변의 점 개수는 이전 단계 점의 개수 + $2^{\text{현재 단계}}$만큼 증가한다.

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **규칙 찾기 (점화식)**
	- 0단계: 한 변 2개 $\rightarrow$ 전체 $2^2 = 4$
	- 1단계: 한 변 $2 + 1 = 3$개 $\rightarrow$ 전체 $3^2 = 9$ (증가량 $2^0$)
	- 2단계: 한 변 $3 + 2 = 5$개 $\rightarrow$ 전체 $5^2 = 25$ (증가량 $2^1$)
	- 3단계: 한 변 $5 + 4 = 9$개 $\rightarrow$ 전체 $9^2 = 81$ (증가량 $2^2$)
   
2. **알고리즘 설계**
	- 초기 한 변의 점 개수 `a = 2`로 설정.
	- 입력받은 `n`번만큼 반복문을 돌며 한 변의 점 개수를 증가시킨다.
	- 증가 식: `a = a + 2^i` (여기서 `i`는 0부터 `n-1`까지)
	- 최종적으로 `a * a`를 출력한다.

3. **시간 복잡도:**
	- 반복문이 $N$번 수행되므로 $O(N)$. $N$이 최대 15이므로 매우 빠름.

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Bronze/2903. 중앙 이동 알고리즘/)

```java
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
		
        int n = sc.nextInt();
        int a = 2; // 0단계에서 한 변의 점 개수
		
        // N번 반복하며 한 변의 점 개수 갱신
        for (int i = 0; i < n; i++) {
            a = a + (int) Math.pow(2, i);
        }
		
        // 전체 점의 개수 = 한 변의 점 개수 * 한 변의 점 개수
        System.out.println(a * a);
    }
}
```

---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **배운 점:** 
	- 도형이 분할될 때 점의 개수가 늘어나는 규칙(수열)을 파악하여 코드로 구현하는 능력을 연습함.
	- `Math.pow`는 `double`형을 반환하므로 `int`형 변환이 필요함을 확인함.
- **다른 사람 풀이 참고 (수학적 공식):**
	- 반복문을 쓰지 않고 일반항 공식을 사용하면 $O(1)$로도 풀 수 있음.
	- 한 변의 점 개수 공식: $2^N + 1$
	- 답: $(2^N + 1)^2$
	- 예: `Math.pow(Math.pow(2, n) + 1, 2)`