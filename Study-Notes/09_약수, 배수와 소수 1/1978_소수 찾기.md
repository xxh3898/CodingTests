# 2026-01-07
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **요약**: 주어진 $N$개의 수 중에서 '소수(Prime Number)'가 몇 개인지 개수를 세어 출력하는 문제.
- **핵심 조건**: 
	- **소수의 정의**: 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수.
	- 즉, 약수의 개수가 정확히 **2개**인 수가 소수이다.
	- **주의**: `1`은 소수가 아니다 (약수가 1개뿐).

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **변수 설정:** 
	- 입력받을 수의 개수 `n`.
	- 각 수를 검사할 때 약수의 개수를 셀 `count`.
	- 최종적으로 소수의 개수를 저장할 `sum`.

2. **로직 설계 (이중 반복문):** 
	- 외부 루프: 입력받은 $N$개의 숫자를 하나씩 꺼낸다 (`num`).
	- 내부 루프: 1부터 `num`까지 반복하며 `num`을 나누어 본다.
	- 조건문: `num % j == 0`이면 약수이므로 `count`를 증가시킨다.
	- 판별: 내부 루프가 끝난 후 `count`가 **2**라면 소수이므로 `sum`을 증가시킨다. (1은 약수가 1개라 걸러지고, 합성수는 3개 이상이라 걸러짐)

3. **시간 복잡도:** 
- 어떤 수 $K$에 대해 소수인지 판별하기 위해 $K$번 반복함.
	  - 전체 $N$개의 수에 대해 수행하므로 최악의 경우 $O(N \times K)$.
	  - 문제 조건에서 $K \le 1000$이므로 충분히 통과 가능.

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Bronze/1978. 소수 찾기/)

---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **성공 요인:** 
	- 소수의 정의(약수가 2개)를 정확히 이용하여, `count == 2` 조건을 통해 1(약수 1개)과 합성수(약수 3개 이상)를 한 번에 잘 필터링함.
	- `BufferedReader`와 `StringTokenizer`를 사용하여 효율적인 입출력을 구현함.
  
- **배운 점:**
	- 이중 반복문을 사용할 때 내부 변수(`count`)를 적절한 시점에 초기화해야 한다는 점을 다시 확인.

- **다른 사람 풀이 참고 (최적화 방법):**
	- **제곱근까지만 확인하기 ($O(\sqrt{N})$)**:
	    - 소수를 판별할 때 굳이 자기 자신까지 나눌 필요 없이, $2$부터 $\sqrt{\text{num}}$까지만 나누어 떨어지는지 확인하면 된다.
	    - 만약 그 범위 내에서 나누어 떨어지는 수가 있다면 소수가 아님 (`break`).
	    - 이 방법을 쓰면 숫자가 커질 때 훨씬 효율적이다.
  - **에라토스테네스의 체**:
    - 범위 내의 모든 소수를 구할 때는 배열을 만들어 배수를 지워나가는 방식이 가장 빠르다. (이번 문제는 개별 숫자 판별이라 필수까진 아님)