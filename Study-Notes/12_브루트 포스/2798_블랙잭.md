# 2026-02-18
## 💡 문제 이해
> 문제를 나만의 언어로 요약해서 적어보세요.

- **문제 요약**: N장의 카드 중 3장을 골라 합이 M을 넘지 않으면서 M에 가장 가까운 값을 찾아야 함.
- **핵심 조건**: 
    1. 카드의 합은 $M$ 이하일 것.
    2. 중복된 카드를 뽑을 수 없음.
    3. $N$의 범위가 100 이하로 작으므로 모든 경우의 수를 다 확인하는 완전 탐색이 가능함.

---

## 🚀 접근 방식 (Logic)
> 코드를 짜기 전, 어떤 알고리즘과 자료구조를 쓸지 설계하는 단계입니다.

1. **변수 설정:** 
	- `int n`: 카드의 개수
    - `long m`: 목표 숫자
    - `int[] arr`: 카드 숫자들이 담긴 배열
    - `long result`: 현재까지 찾은 $M$에 가장 가까운 합
2. **조건문 설계:** 
	- 3중 `for`문을 사용하여 모든 카드 조합($_{N}C_{3}$)을 탐색.
    - 각 루프의 시작점은 이전 루프의 인덱스 + 1로 설정하여 중복 방지.
    - `if (tempSum <= m)` 조건 내에서 `result = Math.max(result, tempSum)` 수행.
3. **시간 복잡도:** 
	- $O(N^3)$ -> $N$이 100일 때 약 16만 번 연산이므로 1초 이내 충분히 통과 가능.

---

## 💻 소스 코드 및 문제 설명
> 백준허브가 자동 생성한 **문제 폴더**로 이동합니다.

- [📂 문제 풀이 폴더 열기 (소스코드 & README)](../../백준/Bronze/2798. 블랙잭)

---

## 📝 오답 노트 & 회고
> 틀렸다면 왜 틀렸는지, 맞았다면 더 좋은 방법은 없는지 기록하세요.

- **틀린 이유:** 
	- 반복문의 종료 조건 설정 오류. `i < n - 3`, `j < n - 2`, `k < n - 1`로 설정하여 배열의 마지막 카드를 포함하는 경우의 수를 탐색하지 못함. 
	- 인덱스 범위 계산 시, 마지막 루프가 실제 배열의 끝(`n-1`)까지 닿을 수 있도록 설계해야 함.
- **배운 점:**
	- 3중 루프에서 각 변수가 가질 수 있는 최댓값을 정확히 계산하는 것이 중요함.
	- `result == m`인 경우 즉시 `break`를 걸어 불필요한 연산을 줄이는 최적화 기법을 배움.
- **다른 사람 풀이 참고:**
	- 합이 $M$을 넘는 경우를 미리 걸러내거나(`if (arr[i] + arr[j] >= m) continue`), 정렬 후 탐색을 중단하는 방식 등으로 성능을 더 개선할 수 있음.````